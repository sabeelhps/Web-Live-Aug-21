{
  "version": 3,
  "sources": ["../../../../../../lib/dialects/abstract/query-generator/helpers/quote.js"],
  "sourcesContent": ["/**\n * Quote helpers implement quote ability for all dialects.\n * These are basic block of query building\n *\n * Its better to implement all dialect implementation together here. Which will allow\n * even abstract generator to use them by just specifying dialect type.\n *\n * Defining these helpers in each query dialect will leave\n * code in dual dependency of abstract <-> specific dialect\n */\n\n'use strict';\n\nconst Utils = require('../../../../utils');\n\n/**\n * list of reserved words in PostgreSQL 10\n * source: https://www.postgresql.org/docs/10/static/sql-keywords-appendix.html\n *\n * @private\n */\nconst postgresReservedWords = 'all,analyse,analyze,and,any,array,as,asc,asymmetric,authorization,binary,both,case,cast,check,collate,collation,column,concurrently,constraint,create,cross,current_catalog,current_date,current_role,current_schema,current_time,current_timestamp,current_user,default,deferrable,desc,distinct,do,else,end,except,false,fetch,for,foreign,freeze,from,full,grant,group,having,ilike,in,initially,inner,intersect,into,is,isnull,join,lateral,leading,left,like,limit,localtime,localtimestamp,natural,not,notnull,null,offset,on,only,or,order,outer,overlaps,placing,primary,references,returning,right,select,session_user,similar,some,symmetric,table,tablesample,then,to,trailing,true,union,unique,user,using,variadic,verbose,when,where,window,with'.split(',');\n\n/**\n * list of reserved words in Snowflake\n * source: https://docs.snowflake.com/en/sql-reference/reserved-keywords.html\n * \n * @private\n */\nconst snowflakeReservedWords = 'account,all,alter,and,any,as,between,by,case,cast,check,column,connect,connections,constraint,create,cross,current,current_date,current_time,current_timestamp,current_user,database,delete,distinct,drop,else,exists,false,following,for,from,full,grant,group,gscluster,having,ilike,in,increment,inner,insert,intersect,into,is,issue,join,lateral,left,like,localtime,localtimestamp,minus,natural,not,null,of,on,or,order,organization,qualify,regexp,revoke,right,rlike,row,rows,sample,schema,select,set,some,start,table,tablesample,then,to,trigger,true,try_cast,union,unique,update,using,values,view,when,whenever,where,with'.split(',');\n\n/**\n *\n * @param {string}  dialect         Dialect name\n * @param {string}  identifier      Identifier to quote\n * @param {object}  [options]\n * @param {boolean} [options.force=false]\n * @param {boolean} [options.quoteIdentifiers=true]\n *\n * @returns {string}\n * @private\n */\nfunction quoteIdentifier(dialect, identifier, options) {\n  if (identifier === '*') return identifier;\n\n  options = Utils.defaults(options || {}, {\n    force: false,\n    quoteIdentifiers: true\n  });\n\n  switch (dialect) {\n    case 'sqlite':\n    case 'mariadb':\n    case 'mysql':\n      return Utils.addTicks(Utils.removeTicks(identifier, '`'), '`');\n    case 'db2':\n      return Utils.addTicks(Utils.removeTicks(identifier, '\"'), '\"');\n    case 'snowflake':\n    case 'postgres':\n      const rawIdentifier = Utils.removeTicks(identifier, '\"');\n\n      if (\n        options.force !== true &&\n        options.quoteIdentifiers === false &&\n        !identifier.includes('.') &&\n        !identifier.includes('->') &&\n        (dialect === 'postgres' && !postgresReservedWords.includes(rawIdentifier.toLowerCase()) || dialect === 'snowflake' && !snowflakeReservedWords.includes(rawIdentifier.toLowerCase()))\n      ) {\n        // In Postgres and Snowflake, if tables or attributes are created double-quoted,\n        // they are also case sensitive. If they contain any uppercase\n        // characters, they must always be double-quoted. This makes it\n        // impossible to write queries in portable SQL if tables are created in\n        // this way. Hence, we strip quotes if we don't want case sensitivity.\n        return rawIdentifier;\n      }\n      return Utils.addTicks(rawIdentifier, '\"');\n    case 'mssql':\n      return `[${identifier.replace(/[[\\]']+/g, '')}]`;\n\n    default:\n      throw new Error(`Dialect \"${dialect}\" is not supported`);\n  }\n}\nmodule.exports.quoteIdentifier = quoteIdentifier;\n\n/**\n * Test if a give string is already quoted\n *\n * @param {string} identifier\n *\n * @returns {boolean}\n * @private\n */\nfunction isIdentifierQuoted(identifier) {\n  return /^\\s*(?:([`\"'])(?:(?!\\1).|\\1{2})*\\1\\.?)+\\s*$/i.test(identifier);\n}\nmodule.exports.isIdentifierQuoted = isIdentifierQuoted;\n"],
  "mappings": ";AAaA,MAAM,QAAQ,QAAQ;AAQtB,MAAM,wBAAwB,iuBAAiuB,MAAM;AAQrwB,MAAM,yBAAyB,4mBAA4mB,MAAM;AAajpB,yBAAyB,SAAS,YAAY,SAAS;AACrD,MAAI,eAAe;AAAK,WAAO;AAE/B,YAAU,MAAM,SAAS,WAAW,IAAI;AAAA,IACtC,OAAO;AAAA,IACP,kBAAkB;AAAA;AAGpB,UAAQ;AAAA,SACD;AAAA,SACA;AAAA,SACA;AACH,aAAO,MAAM,SAAS,MAAM,YAAY,YAAY,MAAM;AAAA,SACvD;AACH,aAAO,MAAM,SAAS,MAAM,YAAY,YAAY,MAAM;AAAA,SACvD;AAAA,SACA;AACH,YAAM,gBAAgB,MAAM,YAAY,YAAY;AAEpD,UACE,QAAQ,UAAU,QAClB,QAAQ,qBAAqB,SAC7B,CAAC,WAAW,SAAS,QACrB,CAAC,WAAW,SAAS,SACpB,aAAY,cAAc,CAAC,sBAAsB,SAAS,cAAc,kBAAkB,YAAY,eAAe,CAAC,uBAAuB,SAAS,cAAc,iBACrK;AAMA,eAAO;AAAA;AAET,aAAO,MAAM,SAAS,eAAe;AAAA,SAClC;AACH,aAAO,IAAI,WAAW,QAAQ,YAAY;AAAA;AAG1C,YAAM,IAAI,MAAM,YAAY;AAAA;AAAA;AAGlC,OAAO,QAAQ,kBAAkB;AAUjC,4BAA4B,YAAY;AACtC,SAAO,+CAA+C,KAAK;AAAA;AAE7D,OAAO,QAAQ,qBAAqB;",
  "names": []
}
